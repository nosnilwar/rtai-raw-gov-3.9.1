<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html><head>


   <title>RT-Linux</title>
   <meta http-equiv="content-type" content="text/html; charset=ISO-8859-2">
   <meta name="GENERATOR" content="Mozilla/3.04Gold (X11; I; Linux 2.0.33 i586) [Netscape]">
   <meta name="Author" content="Grzegorz Ca³kowski">
   <meta name="Keywords" content="Linux, kernel, scheduling, realtime">
</head><body>

<p><i><a href="http://linux.msstudio.com.pl/LabLinux/PROCESY/index.html" tppabs="http://rainbow.mimuw.edu.pl/SO/LabLinux/PROCESY/index.html">Do spisu tre¶ci tematu 3</a></i></p>

<h1 align="center">3.3.5 RT-Linux</h1>

<center><p>&nbsp;&nbsp;&nbsp;</p></center>

<h2 align="center">Spis tre¶ci</h2>

<ul>
<li><a href="#wprowadzenie">Wprowadzenie</a></li>

<li><a href="#przerwania">Emulacja przerwañ</a></li>

<li><a href="#zegar_systemowy">Zegar systemowy</a></li>

<li><a href="#procesy">Procesy czasu rzeczywistego i szeregowanie</a></li>

<li><a href="#ipc">Komunikacja miêdzy procesami</a></li>

<li><a href="#podsumowanie">Podsumowanie</a></li>

<li><a href="#biblografia">Bibliografia</a></li>
</ul>

<p>
</p><hr width="100%"><p></p>

<h2 align="center"><a name="wprowadzenie"></a>Wprowadzenie</h2>

<p>Podstawow± cech± komputerowego systemu czasu rzeczywistego jest zdolno¶æ
do odpowiednio krótkiej reakcji na zdarzenia generowane przez urz±dzenia
zewnêtrzne. Typowym zastosowaniem takich systemów s± pomiary, sterowanie
urz±dzeniami przemys³owymi, itp. <br>
<br>
System operacyjny czasu rzeczywistego to system <u>gwarantuj±cy</u> spe³nianie
wymogów czasowych zwi±zanych z wykonywanymi procesami.<br>
<br>
W j±drze Linuxa, pocz±wszy od wersji 2.0.0, zaimplementowano tryby szeregowania
dla procesów czasu rzeczywistego, zgodne ze specyfikacj± POSIX.1b (Round-Robin
oraz FIFO). Nie wystarcza to jednak, aby mo¿na by³o uznaæ Linux za system
czasu rzeczywistego. W zadaniach takich Linux sie, po prostu, nie sprawdza.
Wynika to przede wszystkim z: czêstego wy³±czania przerwañ w celu ochrony
krytycznych czê¶ci kodu j±dra, opó¼nieñ w procedurach obs³ugi przerwañ,
nie daj±cych siê przewidzieæ opó¼nieñ zwi±zanych z pamiêci± wirtualn±,
charakterystki szeregowania procesów i ma³ej czêstotliwo¶ci zegarów systemowych.
Podstawow± cech± Linuxa jest to, i¿ proces znajduj±cy siê trybie j±dra
nie mo¿e zostaæ wyw³aszczony przez inny proces. Upraszcza to znacz±co implementacjê,
gdy¿ nie trzeba przejmowaæ siê wielowej¶ciowo¶ci± (ang. <i>reentrant</i>)
funkcji systemowych. Poniewa¿ wykonanie funkcji systemowej mo¿e trwaæ do¶æ
d³ugo, opó¼nia to wznowienie procesu<i> realtime </i>i, w efekcie, uniemo¿liwia
odpowiednio szybk± reakcjê na zdarzenie zewnêtrzne.</p>

<p>Z uwagi na du¿e zapotrzebowanie na ogólnodostêpny system operacyjny
czasu rzeczywistego podjêto wysi³ki nad modernizacj± Linuxa. Projekt ten
nosi nazwê <i>"A Linux-based Real-Time Operating System"</i>,
w skrócie: <b>RT-Linux</b>. Dostêpny jest tylko dla architektur oparych
na procesorach Intela.</p>

<p>Niniejszy opis dotyczy g³ównie algorytmów szeregowania udostêpnianych
przez RT-Linux. Krótko opiszê tak¿e inne modyfikacje j±dra systemu.</p>

<p>
</p><hr width="100%"><p></p>

<h2 align="center"><a name="przerwania"></a>Emulacja przerwañ</h2>

<p>Jednym ze wspomnianych problemów, uniemo¿liwiaj±cych szybk± reakcjê
systemu, jest notoryczne wy³±czanie przerwañ w kodzie j±dra, s³u¿±ce synchronizacji
w krytycznych czê¶ci kodu. Postanowiono <u>ca³kowicie</u> wyeliminowaæ
w³±czanie i wy³±czanie przerwañ. Okaza³o siê to mo¿liwe, dziêki bardzo
sprytnej metodzie, polegaj±cej na wprowadzeniu warstwy emulacji przechwytuj±cej
przerwania sprzêtowe. Wszystkie wyst±pienia instrukcji <tt>cli, sti, iret</tt>
odpowiedzialnych, odpowiednio: za wy³±czanie przerwañ, ich w³±czanie oraz
powrót z procedury obs³ugi przerwania zast±piono makrodefinicjami: <tt>S_CLI,
S_STI </tt>oraz <tt>S_IRET.</tt></p>

<p>Jak to dzia³a? Gdy w standardowym j±drze, w wyniku wykonania instrukcji
<tt>cli</tt> przyjmowanie przerwañ zosta³oby zablokowane, w "emulatorze"
ten fakt jest zapamiêtywany przez ustawienie odpowiedniej flagi. Przerwania
pozostaj± nadal w³±czone. Je¶li w sekcji krytycznej wyst±pi przerwanie
i flaga jest ustawiona - wykonanie procedury obs³ugi przerwania zostaje
prze³o¿one na pó¼niej, a¿ do wykonania instrukcji <tt>sti</tt>.</p>

<p>
</p><hr width="100%"><p></p>

<h2 align="center"><a name="zegar_systemowy"></a>Zegar systemowy</h2>

<p>Zegar systemowy w standardowym Linuxie "tyka", jak na potrzeby
systemów czasu rzeczywistego, stosunkowo wolno - 100 razy na sekundê. Znaczy
to, ¿e 100 razy na sekundê dochodzi do przerwania pracy procesora i przej¶cia
do procedury obs³ugi przerwania zegarowego (funkcja timer_interrupt() w
arch/i386/kernel/time.c). Przerwania tego typu maj± miejsce w <u>sta³ych</u>
odstêpach czasu (tzw. <i>periodic clocks</i>). Uzyskanie odpowiednio wysokiej
dok³adno¶ci pracy zegara jest kompromisem na rzecz opó¼nieñ zwi±zanych
z ich obs³ug± - przerwania kosztuj±.</p>

<p>W j±drze RT-Linuxa postanowiono wykorzystaæ specjalny uk³ad zegara Intel
8354 oraz wewnêtrzne zegary procesora Pentium. Zegar taki mo¿e byæ zaprogramowany
w taki sposób, ¿e po zadanym czasie, okre¶lonym z dok³adno¶ci± do 1 mikrosekundy,
generowane jest przerwanie. Dziêki temu narzut zwi±zany z przerwaniami
jest bardzo ma³y, gdy¿ do przerwania dochodzi tylko wtedy, gdy jest potrzebne,
a nie ci±gle, w sta³ych odstêpach czasu. </p>

<h2 align="center">
<hr width="100%"></h2>

<h2 align="center"><a name="procesy"></a>Procesy czasu rzeczywistego i szeregowanie</h2>

<p>Jest to swoista rewolucja w j±drze Linuxa. Wprowadzono specjaln± klasê
procesów - <u>realtime tasks</u>. Procesy te ca³y czas wykonywane s± w
<u>trybie j±dra</u>, wspó³dziel±c z j±drem przestrzeñ adresow±. Poci±ga
to za sob± nastêpuj±ce skutki:&nbsp;&nbsp;&nbsp;</p>

<ul>
<li>Szeregowanie procesów pracuj±cych na tym samym poziomie ochrony jest
tañsze dziêki programowej, nie sprzêtowej, realizacji. Zmiana kontekstu
sprowadza siê do zapamiêtania rejestrów i ich ponownego za³adowania. Odpada
narzut zwi±zany ze zmian± trybu pracy procesora oraz z czyszczeniem rejestrów
asoscjacyjnych procesora (chodzi o tzw. TLB, <i>translation lookaside buffer</i>,
który musi byæ uniewa¿niony w momencie zmiany rejestru bazowego uk³adu
zarz±dzaj±cego pamiêci±).<br>
&nbsp;&nbsp;&nbsp;</li>

<li>Wspólna przestrzeñ adresowa godzi w stabilno¶æ systemu. B³±d w programie
wykonuj±cym siê jako proces realtime mo¿e doprowadziæ do awarii systemu.<br>
&nbsp;&nbsp;&nbsp;</li>

<li>Procesy realtime mog± komunikowaæ siê i wspó³dzieliæ dane bezpo¶rednio.<br>
&nbsp;&nbsp;&nbsp;</li>

<li>Rozmiar stosu procesów jest sta³y - okre¶lany w momencie tworzenia
procesu.</li>
</ul>

<p>Do zaimplementowania procesów wykonuj±cych siê w trybie j±dra skorzystano
z cennej cechy Linuxa, polegaj±cej na dynamicznym ³adowaniu i usuwaniu
tzw. modu³ów j±dra.</p>

<p>Co wiêcej, fragmenty kodu odpowiedzialne za szeregowanie procesów realtime
mog± byæ tak¿e skonfigurowane jako modu³y j±dra. Umo¿liwia to u¿ytkownikowi
napisanie w³asnego schedulera i uruchomienie go "w locie", bez
potrzeby rekompilacji j±dra. <br>
&nbsp;&nbsp;&nbsp;</p>

<h3>Struktura <tt>rt_task_struct</tt></h3>

<p>Z ka¿dym z procesów realtime zwi±zana jest struktura <tt>rt_task_struct</tt>.
Istotne jej pola to:</p>

<ul>
<li><b><tt>state</tt></b> - okre¶la stan procesu. Mo¿liwe stany to:<br>
<br>
<tt>RT_TASK_READY</tt> - proces jest gotowy do wykonania (znajduje siê
w kolejce procesów gotowych)<br>
<br>
<tt>RT_TASK_DORMANT </tt>- proces wstrzymany; mo¿e zostaæ wznowiony tylko
przez inny proces<br>
<br>
<tt>RT_TASK_DELAYED</tt> - dla procesów "okresowych"; wznowienie
procesu od³o¿one jest do chwili okre¶lonej przez pole <tt>resume_time</tt>
<br>
&nbsp;&nbsp;&nbsp;</li>

<li><b><tt>priority</tt></b> - warto¶æ priorytetu procesu z zakresu 0...1000000<br>
&nbsp;&nbsp;&nbsp;&nbsp;</li>

<li><b><tt>resume_time</tt></b> - dla procesów "okresowych";
godzina "budzenia" procesu <br>
&nbsp;&nbsp;&nbsp;&nbsp;</li>

<li><b><tt>period </tt></b>- dla procesów "okresowych"; okre¶la
odstêp czasu miêdzy kolejnymi wznowieniami procesu</li>
</ul>

<h3><br>
Zmienna <tt>rt_linux_task</tt></h3>

<p>Struktura opisuj±ca "proces" j±dra. J±dro wraz ze wszystkimi
"zwyk³ymi" procesami stanowi osobny proces (w odniesieniu do
procesów realtime) i ma najni¿szy priorytet.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>

<h3>Zmienna <tt>rt_tasks</tt></h3>

<p>Wska¼nik na pierwszy proces realtime. Wszystkie procesy, w³±cznie z
<tt>rt_linux_task</tt> powi±zane s± w jedn± listê, bez wzglêdu na ich stan
(nie tworzy siê osobnej kolejki procesów gotowych).</p>

<h3><br>
<b>Priority-based Rate Monotonic Scheduling Algorithm</b></h3>

<p>Jest to podstawowy algorytm szeregowania dostêpny w RT-Linuxie. Ka¿dy
z procesów realtime ma przydzielony unikatowy priorytet (ni¿sza warto¶æ
oznacza wy¿szy priorytet; unikatowo¶æ priorytetów nie jest sprawdzana!).
Procesom nie przydziela siê kwantu czasu na dzia³anie - zak³ada siê, ¿e
procesy realtime same oddadz± procesor. Proces wyw³aszczany jest tylko
wtedy, gdy pojawia siê gotowy proces o wy¿szym priorytecie. Proces realtime
mo¿e byæ procesem "okresowym" - bêdzie wznawiany w równych odstêpach
czasu, o ile nie dzia³a proces o wy¿szym priorytecie.</p>

<p>Schemat algorytmu:</p>

<ul>
<pre>rt_schedule()
{
&nbsp;&nbsp;&nbsp;for (ka¿dy gotowy proces realtime)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wybierz proces o najwy¿szym priorytecie;

&nbsp;&nbsp;&nbsp;if (wybrano proces)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (ka¿dy wstrzymany proces realtime o wy¿szym priorytecie ni¿
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                  priorytet wybranego procesu)
&nbsp;      &nbsp;  wybierz proces, który powinien byæ wznowiony najwcze¶niej;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (wybrano wstrzymany proces)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ustaw zegar na czas "budzenia" procesu &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   
   }
&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wybierz "proces" j±dra;

   wznów wybrany proces;
}</pre>

<pre>wake_up()
{
&nbsp;&nbsp;&nbsp;dodaj proces do kolejki procesów gotowych;

&nbsp;&nbsp;&nbsp;if (priorytet "budzonego"&nbsp;procesu &gt; priorytet procesu bie¿±cego)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rt_schedule();
}
&nbsp;&nbsp;&nbsp;&nbsp;</pre>
</ul>

<h3><b>Earliest Deadline First Algorithm (EDF)</b></h3>

<p>Jest to jeszcze prostszy algorytm. Wszystkie procesy realtime maj± taki
sam priorytet, wy¿szy, oczywi¶cie, ni¿ priorytet procesu "j±dra".
Do struktury <tt>rt_task_struct </tt>dodano pole <b><tt>absolute_deadline</tt></b>,
okre¶laj±ce ostateczny czas wznowienia procesu.</p>

<p>Schemat algorytmu:</p>

<ul>
<pre><tt>rt_schedule()
{
&nbsp;&nbsp;&nbsp;for (ka¿dy gotowy proces realtime)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wybierz proces o najmniejszej warto¶ci absolute_deadline;

&nbsp;&nbsp;&nbsp;if (wybrano proces)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (ka¿dy wstrzymany proces&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  wybierz proces, który powinien byæ wznowiony najwcze¶niej; </tt></pre>

<pre><tt>&nbsp;&nbsp;&nbsp;    if (wybrano wstrzymany proces)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ustaw zegar na czas "budzenia" procesu
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wybierz "proces" j±dra;</tt></pre>

<pre><tt>&nbsp;&nbsp;&nbsp;wznów wybrany proces;
}
&nbsp;&nbsp;&nbsp;</tt></pre>
</ul>

<h3>Funkcje i sta³e</h3>

<ul>
<li><tt>int rt_task_init(RT_TASK *task, void (*fn)(int data), int data,
int stack_size, int priority); <br>
<br>
</tt>Utworzenie nowego procesu realtime. Znaczenie parametrów:<br>
<tt>task - </tt>wska¼nik na strukturê <tt>rt_task_struct </tt>nowego procesu
<br>
<tt>fn - </tt>funkcja, która zostanie wywo³ana przez nowo utworzony proces<br>
<tt>data</tt> - parametr przekazywany funkcji <tt>fn<br>
stack_size</tt> - rozmiar stosu jaki bêdzie przydzielony procesowi<br>
<tt>priority</tt> - priorytet procesu<br>
</li>

<li>&nbsp;<tt>int rt_task_make_periodic(RT_TASK *task, RTIME start_time, RTIME
period)<br>
<br>
</tt>Prze³±czenie procesu w tryb "okresowy". Proces zostanie
uruchomiony o czasie <tt>start_time</tt> i bêdzie wznawiany co <tt>period</tt>
jednostek czasu<br>
&nbsp;&nbsp;&nbsp;</li>

<li><tt>int rt_task_delete(RT_TASK *task)<br>
<br>
</tt>Usuniêcie procesu.<br>
&nbsp;&nbsp;&nbsp;</li>

<li><tt>int rt_task_wait(void)<br>
<br>
</tt>Wstrzymanie wykonywania bie¿±cego procesu.<br>
&nbsp;&nbsp;&nbsp;</li>

<li><tt>int rt_task_suspend(RT_TASK *task)<br>
<br>
</tt>Wstrzymanie wykonywania wskazanego procesu. <br>
&nbsp;&nbsp;&nbsp;</li>

<li><tt>int rt_task_wakeup(RT_TASK *task)<br>
<br>
</tt>Wznowienie wskazanego procesu.<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;</tt></li>

<li><tt>void rt_use_fp(int flag)<br>
</tt>&nbsp;<br>
Ustawienie flagi (dla bie¿±cego procesu) mówi±cej czy proces bêdzie u¿ywa³
koprocesora matematycznego. Ma to wp³yw na zachowywany kontekst procesu.<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;</tt></li>

<li><tt>RTIME rt_get_time(void); <br>
<br>
</tt>Zwraca warto¶æ wewnêtrznego zegara RT-Linux. Zegar ten nie jest synchronizowany
ze "standardowymi" zegarami j±dra Linuxa. Czas wyra¿any jest
w wewnêtrznych jednostkach równych "mniej wiêcej" 1 mikrosekundzie.
(Sta³a <tt>RT_TICKS_PER_SEC </tt>okre¶la liczbê tykniêæ zegara w czasie
sekundy, standardowo wynosi 1193180).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
</li>
</ul>

<p>
</p><hr width="100%"><p></p>

<h2 align="center"><a name="ipc"></a>Komunikacja miêdzy procesami</h2>

<p>Z procesami realtime zwi±zane jest istotne ograniczenie. Proces taki
nie mo¿e wywo³ywaæ ¿adnej ze standardowych funkcji systemowych j±dra. Wynika
to z tego, i¿ (wiêkszo¶æ) funkcji j±dra nie jest wielowej¶ciowa. Proces
wykonuj±cy funkcjê j±dra móg³by zostaæ wyw³aszczony przez inny proces,
który móg³by np. wywo³aæ tê sam± funkcjê systemow±. Dlatego wprowadzono
specjalny mechanizm komunikacji, nazwany RT-FIFO, pomiêdzy procesami realtime
a procesem j±dra oraz pomiêdzy procesami realtime a zwyk³ymi procesami.
Idea dzia³ania tego mechanizmu jest bardzo podobna do standardowych ³±cz
FIFO.<br>
<br>
Bufory RT-FIFO tworzone s± w przestrzeni pamiêci j±dra. Identyfikowane
s± przez "globalne" klucze, bêd±ce liczbami ca³kowitymi.<br>
<br>
Dostêpne operacje na kolejkach RT-FIFO (dla procesów realtime):</p>

<ul>
<li><tt>int rtf_create(unsigned int fifo, int size</tt>) - utworzenie bufora
RT-FIFO o numerze <tt>fifo</tt> i rozmiarze <tt>size<br>
&nbsp;&nbsp;&nbsp;</tt></li>

<li><tt>int rtf_destroy(unsigned int fifo)- </tt>zlikwidowanie bufora o
zadanym numerze<br>
&nbsp;&nbsp;&nbsp;</li>

<li><tt>int rtf_resize(unsigned int fifo, int new_size)-</tt> zmiana wielko¶ci
bufora <br>
&nbsp;&nbsp;&nbsp;&nbsp;</li>

<li><tt>int rt_fifo_put(unsigned int fifo, char *buf, int count) - </tt>zapisanie
<tt>count </tt>bajtów wskazywanych przez <tt>buf </tt>(funkcja zwraca -1,
gdy bufor siê przepe³ni, wpp zwraca warto¶æ <tt>count</tt>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;</li>

<li><tt>int rt_fifo_get(unsigned int fifo, char *buf, int count) - </tt>odczytanie
<tt>count</tt> bajtów z bufora pod adres wskazany przez <tt>buf</tt> (funkcja
zwraca -1, gdy w bufor zawiera mniej ni¿ <tt>count</tt> bajtów, wpp zwraca
<tt>count</tt>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>

<li><tt>int rtf_create_handler(unsigned int fifo, int (*handler)(unsigned
int fifo)) </tt>- Przypisanie funkcji obs³ugi do danego bufora. Przekazana
funkcja bêdzie wywo³ywana ka¿dorazowo, gdy "zwyk³y" proces dokona
operacji odczytu/zapisu na buforze. Argumentem funkcji jest nr bufora.</li>
</ul>

<p><br>
"Zwyk³e" procesy z buforów RT-FIFO mog± korzystaæ standardowo,
tak jak z ka¿dych innych urz±dzeñ znakowych. Dodane urz±dzenia odpowiadaj±ce
buforom o kolejnych numerach to: <tt>/dev/rtf0, /dev/rtf1, </tt>itd.</p>

<p>
</p><hr width="100%"><p></p>

<h2 align="center"><a name="podsumowanie"></a>Podsumowanie</h2>

<p>Dziêki bardzo sprytym i stosunkowo niewielkim modyfikacjom uda³o siê
z "ospa³ego" systemu uczyniæ system czasu rzeczywistego. Jest
to kolejny dowód, ¿e Linux jest przemy¶lanym i dobrze zaprojektowanym systemem.
Opisywana wersja RT-Linuxa, 0.5a, znajduje siê w stadium alpha, ale mimo
to wydaje siê byæ stabilna (autorowi opisu nie uda³o siê "roz³o¿yæ"
RT-Linuxa, chyba, ¿e z w³asnej winy przez doprowadzanie do zag³odzenia).
RT-Linux wprowadza now± jako¶æ, czyni±c z Linuxa gro¼nego konkurenta dla
komercyjnych systemów takich jak <a href="http://linux.msstudio.com.pl/tppmsgs/msgs0.htm#74" tppabs="http://www.qnx.com/">QNX</a>.<br>
&nbsp;&nbsp;&nbsp;<br>
Koncepcje wykorzystane w RT-Linuxie przypominaj± system operacyjny, prawie
historycznego ju¿, komputera Amiga - AmigaOS. Jest to wielozadaniowy system,
w którym procesy szeregowane s± typowym algorytmem Round-Robin. Dziêki
temu, i¿ system ten nie udostêpnia pamiêci wirtualnej ani ochrony pamiêci
(wszystkie procesy, jak i j±dro dzia³aj± w tej samej przestrzeni adresowej)
doskonale nadaje siê do zadañ czasu rzeczywistego, w których by³ bardzo
czêsto wykorzystywany.</p>

<p>
</p><hr width="100%"><p></p>

<h2 align="center"><a name="biblografia"></a>Bibliografia</h2>

<ol>
<li>Pliki ¼ród³owe RT-Linux 0.5a</li>

<li>Michael Barabanov <i><a href="http://linux.msstudio.com.pl/tppmsgs/msgs0.htm#75" tppabs="http://luz.cs.nmt.edu/~rtlinux">A Linux-based
Real-Time Operating System</a></i></li>

<li>Ismael Ripoll <i>Earliest Deadline First Algorithm</i></li>
</ol>

<p>
</p><hr width="100%"><i>Autor: Grzegorz Ca³kowski</i> 
<hr width="100%"><p></p>

</body></html>